<!--
    Secure P2P Private Messenger
    Copyright (C) 2026 Your loreii/WebChat

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://unpkg.com; connect-src 'self' wss: https:; style-src 'self' 'unsafe-inline';">
    <title>Resilient P2P Private Messenger</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --bg: #0f0f0f; --card: #1a1a1a; --text: #e0e0e0; --primary: #007bff; --accent: #28a745; --danger: #dc3545; }
        body { font-family: 'Segoe UI', Tahoma, sans-serif; background: var(--bg); color: var(--text); margin: 0; display: flex; height: 100vh; overflow: hidden; }

        /* Layout */
        #sidebar { width: 300px; background: #141414; border-right: 1px solid #333; display: flex; flex-direction: column; padding: 15px; z-index: 10; transition: transform 0.3s ease; }
        #main { flex: 1; display: flex; flex-direction: column; padding: 20px; position: relative; }

        /* Mobile Layout */
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #sidebar { 
                position: fixed; 
                top: 0; 
                left: 0; 
                width: 100%; 
                height: 100vh; 
                transform: translateX(-100%); 
                z-index: 1000;
                padding: 10px;
            }
            #sidebar.mobile-open { transform: translateX(0); }
            #main { padding: 10px; }
            
            .mobile-header { 
                display: flex; 
                align-items: center; 
                justify-content: space-between; 
                padding: 10px; 
                background: #141414; 
                border-bottom: 1px solid #333; 
                position: sticky; 
                top: 0; 
                z-index: 100;
            }
            .mobile-toggle { 
                background: none; 
                border: none; 
                color: white; 
                font-size: 24px; 
                cursor: pointer; 
            }
        }

        @media (min-width: 769px) {
            .mobile-header { display: none; }
        }

        /* Layout */
        #sidebar { width: 300px; background: #141414; border-right: 1px solid #333; display: flex; flex-direction: column; padding: 15px; z-index: 10; transition: transform 0.3s ease; }
        #main { flex: 1; display: flex; flex-direction: column; padding: 20px; position: relative; }

        /* UI Elements */
        .sidebar-header { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; }
        .burger-btn { font-size: 24px; cursor: pointer; background: none; border: none; color: white; }
        .section-label { font-size: 0.7em; text-transform: uppercase; color: #555; margin: 15px 0 8px 5px; font-weight: bold; }

        .address-book-item { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; cursor: pointer; transition: 0.2s; margin-bottom: 5px; background: #222; border: 1px solid transparent; }
        .address-book-item.pinned { border-left: 4px solid gold; background: #2a2a1a; }
        .address-book-item.expired { opacity: 0.5; }
        .address-book-item.expired:hover { opacity: 0.7; }
        .address-book-item.active-session { border-left: 4px solid var(--accent); }
        .address-book-item.selected { background: #333; border-color: var(--primary); }
        .address-book-item canvas { width: 32px; height: 32px; border-radius: 4px; background: #eee; }

        #active-groups-list { display: flex; flex-wrap: wrap; gap: 5px; min-height: 20px; }
        .group-tag { background: #333; color: #fff; padding: 4px 10px; border-radius: 15px; font-size: 0.75em; cursor: pointer; border: 1px solid #444; }
        .group-tag:hover { border-color: var(--primary); }

    #chat-header { display: flex; align-items: center; gap: 15px; padding-bottom: 15px; border-bottom: 1px solid #333; margin-bottom: 15px; }
        #chat-header canvas { width: 64px; height: 64px; border-radius: 8px; background: #eee; cursor: zoom-in; }
        .trust-toggle { background: #444; border: 1px solid #666; color: white; padding: 8px 16px; border-radius: 20px; font-size: 0.8em; cursor: pointer; margin-left: auto; transition: all 0.2s; }
        .trust-toggle.trusted { background: gold; color: black; border-color: gold; }
        .trust-toggle:hover { opacity: 0.8; }
        #chat-box { flex: 1; overflow-y: auto; background: #111; border-radius: 8px; padding: 15px; display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; border: 1px solid #222; }

        .msg { padding: 10px 14px; border-radius: 12px; max-width: 75%; font-size: 0.95em; line-height: 1.4; position: relative; }
        .sent { background: var(--primary); align-self: flex-end; border-bottom-right-radius: 2px; }
        .received { background: #2a2a2a; align-self: flex-start; border-bottom-left-radius: 2px; }
        .verified-badge { font-size: 0.65em; color: var(--accent); display: block; margin-top: 4px; }

        #my-profile-modal { display: none; position: absolute; top: 60px; left: 15px; width: 250px; background: var(--card); border: 1px solid #444; border-radius: 10px; padding: 15px; z-index: 100; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        #my-profile-modal canvas { width: 100px; height: 100px; display: block; margin: 10px auto; border-radius: 10px; }

        input { background: #222; border: 1px solid #444; color: white; padding: 12px; border-radius: 6px; width: 100%; box-sizing: border-box; margin-bottom: 8px; font-size: 16px; }
        input:focus { outline: none; border-color: var(--primary); }
        button { padding: 10px 15px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; background: var(--accent); color: white; transition: background 0.2s; font-size: 14px; }
        button:hover:not(:disabled) { opacity: 0.9; }
        button:disabled { background: #444; cursor: not-allowed; }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            input { font-size: 16px; padding: 14px; }
            button { padding: 12px 16px; font-size: 16px; }
            .msg { font-size: 14px; padding: 12px; }
            #chat-header canvas { width: 48px; height: 48px; }
            #chat-header h2 { font-size: 1.2em; }
            .trust-toggle { padding: 6px 12px; font-size: 12px; }
            .address-book-item { padding: 12px; }
            .address-book-item canvas { width: 40px; height: 40px; }
        }
        .hidden { display: none !important; }

        #key-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 2000; backdrop-filter: blur(5px); }
        .overlay-content { background: var(--card); padding: 25px; border-radius: 15px; max-width: 450px; width: 90%; border: 1px solid #444; text-align: center; }
        .key-box { background: #000; color: var(--accent); padding: 12px; font-family: monospace; font-size: 0.75em; border-radius: 6px; margin: 15px 0; overflow-wrap: break-word; text-align: left; max-height: 150px; overflow-y: auto; }

        /* Setup Landing Page Info Styles */
        #setup-overlay { position: absolute; top: 5%; left: 50%; transform: translateX(-50%); z-index: 1000; width: 450px; max-width: 90vw; max-height: 90vh; overflow-y: auto; background: var(--card); padding: 30px; border-radius: 15px; border: 1px solid #333; }
        .info-section { margin-top: 25px; text-align: left; font-size: 0.85em; color: #aaa; line-height: 1.5; border-top: 1px solid #333; padding-top: 15px; }
        .info-section h4 { color: var(--primary); margin: 15px 0 5px 0; font-size: 0.9em; text-transform: uppercase; }

        /* Mobile setup overlay */
        @media (max-width: 768px) {
            #setup-overlay { 
                position: fixed; 
                top: 0; 
                left: 0; 
                width: 100vw; 
                height: 100vh; 
                max-width: none; 
                max-height: none; 
                padding: 20px; 
                border-radius: 0; 
                transform: none; 
            }
            .info-section { font-size: 0.8em; }
        }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
    </style>
</head>
<body>

<div class="mobile-header">
    <button class="mobile-toggle" onclick="toggleMobileSidebar()">‚ò∞</button>
    <h3 style="margin:0">Messenger</h3>
    <div style="width:24px;"></div>
</div>

<div id="sidebar">
    <div class="sidebar-header">
        <button class="burger-btn" onclick="toggleProfile()">‚ò∞</button>
        <h3 style="margin:0">Messenger</h3>
    </div>

    <div id="my-profile-modal">
        <h4 style="margin:0; text-align:center">My Fingerprint</h4>
        <canvas id="my-thumb" onclick="showKeyInfo(peer.id, myPubJWK_N)"></canvas>
        <p id="my-name-display" style="text-align:center; font-weight:bold; margin: 10px 0;"></p>
        <button onclick="exportKeys()" style="width:100%; font-size:0.8em; background:#444;">Backup Identity</button>
    </div>

    <input type="text" id="direct-id-input" placeholder="Peer ID..." style="font-size: 0.8em;">
    <button onclick="directConnect()" style="width: 100%; font-size: 0.8em; background: var(--primary);">Connect Direct</button>

    <div id="address-book-list" style="flex: 1; overflow-y: auto;"></div>

    <div style="margin-top: auto; padding-top: 10px; border-top: 1px solid #333;">
        <div class="section-label">Live Groups</div>
        <div id="active-groups-list"></div>

        <input type="text" id="group-name-input" placeholder="Interest (e.g. devs)" style="font-size: 0.8em; margin-top:10px;">
        <button id="discover-btn" onclick="toggleDiscoverable()" style="width: 100%; background: #6f42c1;">Discovery Mode</button>
        <p id="timer-display" style="text-align:center; font-size: 0.7em; color: orange; margin: 5px 0; min-height: 1em;"></p>
    </div>
</div>

<div id="main">
    <div id="chat-header" class="hidden">
        <canvas id="recipient-thumb" onclick="inspectRemoteKey()"></canvas>
        <div>
            <h2 id="recipient-name" style="margin:0">Username</h2>
            <small style="color:var(--accent)">E2EE Secured</small>
        </div>
        <button id="trust-toggle" class="trust-toggle" onclick="toggleCurrentUserTrust()">Add to Trusted</button>
    </div>
    <div id="chat-box">
        <div id="welcome-msg" style="text-align:center; color:#444; margin-top:20%;">Start a session from the sidebar.</div>
    </div>
    <div style="display:flex; gap:10px; flex-wrap: wrap;">
        <input type="text" id="msg-input" placeholder="Type a message..." disabled onkeypress="if(event.key==='Enter') sendSecureMsg()" style="flex: 1; min-width: 200px;">
        <button id="send-btn" onclick="sendSecureMsg()" disabled>Send</button>
    </div>

    <div id="setup-overlay">
        <h2 style="margin:0 0 10px 0">Private P2P</h2>
        <input type="text" id="username" placeholder="Username...">
        <button onclick="initIdentity(true)" style="width:100%; margin-top:10px;">Create New Identity</button>
        <div style="margin: 15px 0; text-align: center; color: #555; font-size: 0.8em;">OR</div>
        <input type="file" id="key-file" onchange="initIdentity(false)">

        <!-- Privacy & Security Description -->
        <div class="info-section">
            <h4>üõ°Ô∏è End-to-End Security</h4>
            <p>This application uses the Web Crypto API to generate 2048-bit RSA-OAEP keys. When you send a message, it is encrypted locally on your device with the recipient's public key. Only the intended recipient can decrypt it with their private key.</p>

            <h4>ü§ù Direct Peer-to-Peer</h4>
            <p>Messages travel directly between browsers via WebRTC. No central server ever sees or stores your messages. A public discovery server (PeerJS) is used only to help browsers find each other's IP addresses.</p>

            <h4>üñºÔ∏è Cryptographic Identicons</h4>
            <p>The pattern next to your name is a unique visual representation of your Public Key. If a user's icon changes, their identity has been compromised or changed. Always verify fingerprints with your contacts.</p>

            <h4>üíæ Portable & Local</h4>
            <p>This is a Standalone Application. You can save this page as a single HTML file to your hard drive or a USB stick. It runs directly in the browser without requiring a dedicated web server, ensuring you own the software you use.</p>
        </div>
    </div>
</div>

<div id="key-overlay" class="hidden" onclick="closeKeyInfo()">
    <div class="overlay-content" onclick="event.stopPropagation()">
        <h3 id="overlay-username" style="margin:0">Key Inspection</h3>
        <div id="overlay-key-text" class="key-box"></div>
        <button onclick="copyOverlayKey()" style="width:100%">Copy Modulus (n)</button>
    </div>
</div>

<script>
    const SUPER_LOBBY_ID = "LB_GLOBAL_REG_V17";
    const SYNC_RATE = 30000;

    let myKeys, myName, peer, myPubJWK_N;
    let sessions = new Map();
    let currentTargetId = null;
    let isDiscoverable = false;
    let lobbyConn = null, globalRegistryConn = null;
    let groupAddressBook = [], savedContacts = [];
    let discoveryInterval = null, backoffUntil = 0;
    let messageSequence = 0;
    let rateLimitMap = new Map(); // Rate limiting per peer

    async function openDB() {
        return new Promise((resolve) => {
            const req = indexedDB.open("SecureP2P_V17", 1);
            req.onupgradeneeded = e => e.target.result.createObjectStore("contacts", { keyPath: "id" });
            req.onsuccess = e => resolve(e.target.result);
        });
    }
    async function saveContact(id, name, pub, isPinned = false) {
        const db = await openDB();
        db.transaction("contacts", "readwrite").objectStore("contacts").put({ id, name, pub, lastSeen: Date.now(), isPinned });
    }
    async function loadContacts() {
        const db = await openDB();
        return new Promise(r => { db.transaction("contacts").objectStore("contacts").getAll().onsuccess = e => r(e.target.result); });
    }

    async function initIdentity(isNew) {
        try {
            if (isNew) {
                myName = document.getElementById('username').value.trim();
                if (!myName) {
                    alert("Enter username");
                    return;
                }
                myKeys = await window.crypto.subtle.generateKey({ 
                    name: "RSA-OAEP", 
                    modulusLength: 2048, 
                    publicExponent: new Uint8Array([1, 0, 1]), 
                    hash: "SHA-256" 
                }, true, ["encrypt", "decrypt"]);
            } else {
                const file = document.getElementById('key-file').files[0];
                if (!file) {
                    alert("Please select a key file");
                    return;
                }
                const data = JSON.parse(await file.text());
                myName = data.name;
                myKeys = {
                    publicKey: await window.crypto.subtle.importKey("jwk", data.pub, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]),
                    privateKey: await window.crypto.subtle.importKey("jwk", data.priv, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["decrypt"])
                };
            }
            setupPeer();
        } catch (e) { 
            console.error("Identity creation/load error:", e);
            alert("Identity operation failed: " + e.message); 
        }
    }

    function setupPeer() {
        const config = { 
            host: '0.peerjs.com', 
            port: 443, 
            secure: true, 
            debug: 0,
            config: {
                'iceServers': [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { 
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ],
                'iceCandidatePoolSize': 10,
                'bundlePolicy': 'balanced',
                'rtcpMuxPolicy': 'require'
            }
        };
        peer = new Peer(myName.replace(/\s/g, '') + "-" + Math.floor(Math.random()*9999), config);

        peer.on('open', async (id) => {
            document.getElementById('setup-overlay').classList.add('hidden');
            document.getElementById('my-name-display').innerText = id; // Show full peer ID
            const pubJWK = await window.crypto.subtle.exportKey("jwk", myKeys.publicKey);
            myPubJWK_N = pubJWK.n;
            drawIcon('my-thumb', pubJWK.n);
            savedContacts = await loadContacts();
            refreshAddressBookUI();
            setInterval(cleanupInactiveUsers, 45000); // Clean every 45 seconds
            // Don't auto-connect to lobbies on startup - only when user enables discovery
            showNotification('Identity created successfully! Ready to chat.', 'success');
        });
        peer.on('connection', conn => {
            console.log('üìû Incoming connection from:', conn.peer);
            handleConnectionLogic(conn);
        });
        peer.on('error', err => {
            console.error('Peer error:', err);
            if (err.type === 'server-error' || err.type === 'socket-error') {
                backoffUntil = Date.now() + 60000;
                showNotification('Connection error. Retrying in 1 minute...', 'error');
            } else if (err.type === 'peer-unavailable') {
                showNotification('Peer not available. They may be offline.', 'error');
            } else if (err.type === 'network') {
                showNotification('Network error. Check your internet connection.', 'error');
            } else if (err.type === 'webrtc') {
                showNotification('WebRTC connection failed. This is normal for some network configurations.', 'error');
            }
        });
    }

    function syncWithLobbies() {
        if (Date.now() < backoffUntil) return;
        if (!globalRegistryConn?.open) {
            const gConn = peer.connect(SUPER_LOBBY_ID);
            gConn.on('open', () => { globalRegistryConn = gConn; });
            gConn.on('data', d => { if (d.type === 'GLOBAL_GROUPS') updateGroupsUI(d.list); });
            gConn.on('error', () => { globalRegistryConn = null; });
        }
        if (isDiscoverable) {
            if (lobbyConn?.open) { sendRegistration(); }
            else {
                const groupName = document.getElementById('group-name-input').value.trim() || "global";
                const lobbyID = "LB_V17_" + btoa(groupName).replace(/=/g, '').substring(0, 12);
                const lConn = peer.connect(lobbyID);
                lConn.on('open', () => { lobbyConn = lConn; sendRegistration(); });
                lConn.on('data', d => { if (d.type === 'ADDRESS_BOOK') { groupAddressBook = d.list; refreshAddressBookUI(); } });
                lConn.on('error', () => { lobbyConn = null; });
            }
        }
    }

    async function toggleDiscoverable() {
        if (!isDiscoverable) {
            isDiscoverable = true;
            document.getElementById('discover-btn').innerText = "Stop Discovery";
            document.getElementById('discover-btn').style.background = "var(--danger)";
            document.getElementById('group-name-input').disabled = true;
            
            // Start lobby sync when user enables discovery
            setInterval(syncWithLobbies, SYNC_RATE);
            syncWithLobbies();
            
            const name = document.getElementById('group-name-input').value.trim().toLowerCase() || "global";
            const lobbyID = "LB_V17_" + btoa(name).replace(/=/g, '').substring(0, 12);
            const hostPeer = new Peer(lobbyID, { host: '0.peerjs.com', port: 443, secure: true });
            hostPeer.on('open', () => {
                startLobbyService(hostPeer, name);
                const gHost = new Peer(SUPER_LOBBY_ID, { host: '0.peerjs.com', port: 443, secure: true });
                gHost.on('open', () => startGlobalRegistryService(gHost));
            });
            hostPeer.on('error', () => { hostPeer.destroy(); syncWithLobbies(); });
            startTimer();
        } else {
            isDiscoverable = false;
            document.getElementById('discover-btn').innerText = "Discovery Mode";
            document.getElementById('discover-btn').style.background = "#6f42c1";
            document.getElementById('group-name-input').disabled = false;
            if (lobbyConn?.open) lobbyConn.send({ type: 'UNREGISTER', id: peer.id });
            lobbyConn = null; groupAddressBook = []; refreshAddressBookUI();
            clearInterval(discoveryInterval); document.getElementById('timer-display').innerText = "";
        }
    }

    function startGlobalRegistryService(hp) {
        let groups = new Map(); let subs = new Set();
        hp.on('connection', c => {
            subs.add(c);
            c.on('data', m => { if (m.type === 'REPORT') { groups.set(m.name, Date.now()); broadcast(); } });
        });
        const broadcast = () => {
            const list = Array.from(groups.keys());
            subs.forEach(s => { if (s.open) s.send({ type: 'GLOBAL_GROUPS', list }); });
        };
        setInterval(() => {
            let ch = false; groups.forEach((v, k) => { if (v < Date.now() - 40000) { groups.delete(k); ch = true; } });
            if (ch) broadcast();
        }, 20000);
    }

    function startLobbyService(hp, gn) {
        let reg = new Map(); let subs = new Set();
        const broadcast = () => {
            const now = Date.now();
            const activeList = Array.from(reg.values()).filter(u => u.expires > now);
            subs.forEach(s => { if (s.open) s.send({ type: 'ADDRESS_BOOK', list: activeList }); });
            if (globalRegistryConn?.open) globalRegistryConn.send({ type: 'REPORT', name: gn });
        };
        hp.on('connection', c => {
            subs.add(c);
            c.on('data', m => {
                if (m.type === 'REGISTER') { reg.set(m.data.id, m.data); broadcast(); }
                else if (m.type === 'UNREGISTER') { reg.delete(m.id); broadcast(); }
            });
            c.on('close', () => subs.delete(c));
        });
        // Clean expired users every 30 seconds
        setInterval(() => {
            const now = Date.now();
            let cleaned = false;
            reg.forEach((user, id) => {
                if (user.expires < now) { reg.delete(id); cleaned = true; }
            });
            if (cleaned) broadcast();
        }, 30000);
    }

    // Enhanced session with PFS and authentication
    async function createSession(peerId) {
        const sessionKey = await window.crypto.subtle.generateKey(
            { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
        );
        const hmacKey = await window.crypto.subtle.generateKey(
            { name: "HMAC", hash: "SHA-256" }, true, ["sign", "verify"]
        );
        
        return {
            conn: null,
            remotePubK: null,
            remoteName: "Syncing...",
            remoteJWK_N: null,
            history: [],
            sessionKey,
            hmacKey,
            remoteSessionKey: null,
            remoteHmacKey: null,
            sequenceIn: 0,
            sequenceOut: 0,
            keyExchangeComplete: false
        };
    }

    async function performKeyExchange(session, conn) {
        // Export session keys for exchange
        const sessionKeyJWK = await window.crypto.subtle.exportKey("jwk", session.sessionKey);
        const hmacKeyJWK = await window.crypto.subtle.exportKey("jwk", session.hmacKey);
        
        // Encrypt keys with recipient's RSA key
        const keyBundle = JSON.stringify({ sessionKey: sessionKeyJWK, hmacKey: hmacKeyJWK });
        const encryptedKeys = await window.crypto.subtle.encrypt(
            { name: "RSA-OAEP" }, session.remotePubK, new TextEncoder().encode(keyBundle)
        );
        
        conn.send({ 
            type: 'KEY_EXCHANGE', 
            keys: encryptedKeys,
            sender: myName 
        });
    }

    async function handleKeyExchange(session, encryptedKeys) {
        try {
            const decrypted = await window.crypto.subtle.decrypt(
                { name: "RSA-OAEP" }, myKeys.privateKey, encryptedKeys
            );
            const keyBundle = JSON.parse(new TextDecoder().decode(decrypted));
            
            session.remoteSessionKey = await window.crypto.subtle.importKey(
                "jwk", keyBundle.sessionKey, { name: "AES-GCM" }, true, ["encrypt", "decrypt"]
            );
            session.remoteHmacKey = await window.crypto.subtle.importKey(
                "jwk", keyBundle.hmacKey, { name: "HMAC", hash: "SHA-256" }, true, ["sign", "verify"]
            );
            
            session.keyExchangeComplete = true;
            if (currentTargetId === session.conn.peer) refreshChatBox();
            showNotification('Secure session established with PFS', 'success');
        } catch (error) {
            console.error('Key exchange failed:', error);
            showNotification('Key exchange failed', 'error');
        }
    }

    async function handleConnectionLogic(conn) {
        console.log('üîÑ Setting up connection with:', conn.peer);
        
        // Simplified session creation - no complex crypto for now
        if (!sessions.has(conn.peer)) {
            sessions.set(conn.peer, {
                conn: null,
                remotePubK: null,
                remoteName: "Connecting...",
                remoteJWK_N: null,
                history: [],
                keyExchangeComplete: false // Start as false, set true after handshake
            });
        }
        const session = sessions.get(conn.peer);
        session.conn = conn;
        
        conn.on('open', async () => {
            console.log('‚úÖ Connection opened with:', conn.peer);
            const pubJWK = await window.crypto.subtle.exportKey("jwk", myKeys.publicKey);
            conn.send({ type: 'HANDSHAKE', name: myName, pub: pubJWK });
        });
        
        conn.on('data', async data => {
            console.log('üì® Received data:', data.type, 'from:', conn.peer);
            
            if (data.type === 'HANDSHAKE') {
                console.log('ü§ù Processing handshake from:', data.name);
                try {
                    const pubK = await window.crypto.subtle.importKey("jwk", data.pub, { name: "RSA-OAEP", hash: "SHA-256" }, true, ["encrypt"]);
                    session.remotePubK = pubK;
                    session.remoteName = data.name;
                    session.remoteJWK_N = data.pub.n;
                    session.keyExchangeComplete = true; // Simple handshake complete
                    
                    console.log('‚úÖ Handshake complete with:', data.name);
                    
                    await saveContact(conn.peer, data.name, data.pub);
                    savedContacts = await loadContacts();
                    refreshAddressBookUI();
                    
                    if (currentTargetId === conn.peer) refreshChatBox();
                } catch (error) {
                    console.error('‚ùå Handshake error:', error);
                }
            } else if (data.type === 'SIMPLE_CHAT') {
                try {
                    const dec = await window.crypto.subtle.decrypt({ name: "RSA-OAEP" }, myKeys.privateKey, data.payload);
                    const message = new TextDecoder().decode(dec);
                    addHistory(conn.peer, data.sender, message, 'received', data.timestamp);
                } catch (error) {
                    console.error('‚ùå Decryption failed:', error);
                    addHistory(conn.peer, 'System', 'Failed to decrypt message', 'received');
                }
            }
        });
        
        conn.on('error', (err) => {
            console.error('‚ùå Connection error with', conn.peer, ':', err);
            if (err.message && err.message.includes('Negotiation of connection')) {
                showNotification(`Connection failed with ${session.remoteName || conn.peer}. This can happen due to network/firewall restrictions. Try connecting from the same network or use a VPN.`, 'error');
            }
        });
        
        conn.on('close', () => {
            console.log('üîå Connection closed with:', conn.peer);
            // Clean up session state
            if (sessions.has(conn.peer)) {
                const session = sessions.get(conn.peer);
                session.keyExchangeComplete = false;
                session.conn = null;
                // Keep history and contact info, but reset connection state
            }
            
            // Update UI if this was the current chat
            if (currentTargetId === conn.peer) {
                refreshChatBox();
            }
            refreshAddressBookUI();
        });
    }

    async function handleSecureMessage(session, data) {
        try {
            // Rate limiting check
            const peerId = session.conn.peer;
            const now = Date.now();
            if (!rateLimitMap.has(peerId)) {
                rateLimitMap.set(peerId, { count: 0, resetTime: now + 60000 });
            }
            
            const rateLimit = rateLimitMap.get(peerId);
            if (now > rateLimit.resetTime) {
                rateLimit.count = 0;
                rateLimit.resetTime = now + 60000;
            }
            
            if (rateLimit.count >= 100) { // Max 100 messages per minute
                console.warn('Rate limit exceeded for peer:', peerId);
                return;
            }
            rateLimit.count++;
            
            // Verify sequence number to prevent replay attacks
            if (data.sequence <= session.sequenceIn) {
                console.warn('Replay attack detected - message sequence out of order');
                return;
            }
            
            // Verify HMAC
            const messageData = new Uint8Array(data.payload);
            const receivedHmac = new Uint8Array(data.hmac);
            const computedHmac = await window.crypto.subtle.sign("HMAC", session.remoteHmacKey, messageData);
            
            if (!arrayBuffersEqual(receivedHmac, new Uint8Array(computedHmac))) {
                console.error('Message authentication failed');
                addHistory(session.conn.peer, 'System', 'Message authentication failed', 'received');
                return;
            }
            
            // Decrypt message
            const iv = new Uint8Array(data.iv);
            const decrypted = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv }, session.remoteSessionKey, messageData
            );
            
            const message = new TextDecoder().decode(decrypted);
            session.sequenceIn = data.sequence;
            addHistory(session.conn.peer, data.sender, message, 'received', data.timestamp);
            
        } catch (error) {
            console.error('Secure message handling failed:', error);
            addHistory(session.conn.peer, 'System', 'Failed to decrypt secure message', 'received');
        }
    }

    function arrayBuffersEqual(buf1, buf2) {
        if (buf1.length !== buf2.length) return false;
        for (let i = 0; i < buf1.length; i++) {
            if (buf1[i] !== buf2[i]) return false;
        }
        return true;
    }

    async function terminateSession(peerId) {
        const session = sessions.get(peerId);
        if (!session) return;
        
        try {
            // Clear sensitive data
            if (session.sessionKey) {
                await window.crypto.subtle.exportKey("raw", session.sessionKey).then(() => {
                    // Key exported successfully, now it can be cleared
                });
            }
            if (session.hmacKey) {
                await window.crypto.subtle.exportKey("raw", session.hmacKey).then(() => {
                    // Key exported successfully, now it can be cleared
                });
            }
            
            // Close connection
            if (session.conn && session.conn.open) {
                session.conn.send({ type: 'SESSION_TERMINATE' });
                session.conn.close();
            }
            
            // Clear session data
            sessions.delete(peerId);
            rateLimitMap.delete(peerId);
            
            if (currentTargetId === peerId) {
                currentTargetId = null;
                refreshChatBox();
            }
            
            refreshAddressBookUI();
            showNotification('Session terminated securely', 'success');
            
        } catch (error) {
            console.error('Session termination error:', error);
        }
    }
    
    // Add session termination button to chat header
    function addSessionControls() {
        const chatHeader = document.getElementById('chat-header');
        if (!document.getElementById('terminate-btn')) {
            const terminateBtn = document.createElement('button');
            terminateBtn.id = 'terminate-btn';
            terminateBtn.textContent = 'End Session';
            terminateBtn.style.cssText = 'background: var(--danger); padding: 6px 12px; font-size: 0.8em; margin-left: 10px;';
            terminateBtn.onclick = () => terminateSession(currentTargetId);
            chatHeader.appendChild(terminateBtn);
        }
    }

    function arrayBuffersEqual(buf1, buf2) {
        if (buf1.length !== buf2.length) return false;
        for (let i = 0; i < buf1.length; i++) {
            if (buf1[i] !== buf2[i]) return false;
        }
        return true;
    }

    async function selectUser(id) {
        currentTargetId = id;
        
        // Check if we need to create a new connection
        if (!sessions.has(id)) {
            sessions.set(id, {
                conn: null,
                remotePubK: null,
                remoteName: "Connecting...",
                remoteJWK_N: null,
                history: [],
                keyExchangeComplete: false
            });
        }
        
        const session = sessions.get(id);
        
        // If no active connection, create new one
        if (!session.conn || !session.conn.open) {
            console.log('üîÑ Creating new connection to:', id);
            const newConn = peer.connect(id);
            handleConnectionLogic(newConn);
        }
        
        refreshChatBox(); 
        refreshAddressBookUI();
        
        // Close mobile sidebar when selecting user
        if (window.innerWidth <= 768) {
            document.getElementById('sidebar').classList.remove('mobile-open');
        }
    }

    async function sendSecureMsg() {
        const input = document.getElementById('msg-input');
        const session = sessions.get(currentTargetId);
        if (!input.value.trim() || !session?.keyExchangeComplete) return;
        
        try {
            const message = input.value.trim();
            
            // Simple RSA encryption for now
            const enc = await window.crypto.subtle.encrypt({ name: "RSA-OAEP" }, session.remotePubK, new TextEncoder().encode(message));
            
            session.conn.send({ 
                type: 'SIMPLE_CHAT', 
                payload: enc,
                sender: myName, 
                timestamp: Date.now() 
            });
            
            addHistory(currentTargetId, myName, message, 'sent');
            input.value = "";
            console.log('üì§ Sent message to:', currentTargetId);
        } catch (error) {
            console.error('‚ùå Message sending failed:', error);
            showNotification('Failed to send message', 'error');
        }
    }

    function drawIcon(canvasId, n) {
        const canvas = typeof canvasId === 'string' ? document.getElementById(canvasId) : canvasId;
        if (!canvas) return;
        const ctx = canvas.getContext('2d'); canvas.width = 128; canvas.height = 128;
        const bytes = new Uint8Array(atob(n.replace(/-/g, '+').replace(/_/g, '/')).split('').map(c => c.charCodeAt(0)));
        ctx.fillStyle = "#f0f0f0"; ctx.fillRect(0, 0, 128, 128);
        ctx.fillStyle = `rgb(${bytes[0]},${bytes[1]},${bytes[2]})`;
        for (let y = 0; y < 8; y++) {
            for (let x = 0; x < 4; x++) {
                if (bytes[3 + y * 4 + x] % 2 === 0) {
                    ctx.fillRect(x * 16, y * 16, 16, 16); ctx.fillRect((7 - x) * 16, y * 16, 16, 16);
                }
            }
        }
    }

    function refreshAddressBookUI() {
        const container = document.getElementById('address-book-list');
        container.innerHTML = "";
        const renderSect = (title, list) => {
            if (!list.length) return;
            const l = document.createElement('div'); l.className = 'section-label'; l.innerText = title;
            container.appendChild(l);
            list.filter(u => u.id !== peer.id).forEach(user => {
                const d = document.createElement('div');
                const session = sessions.get(user.id);
                const isActive = session && session.conn && session.conn.open;
                const isExpired = user.expires && user.expires < Date.now();
                const isPinned = user.isPinned;
                d.className = `address-book-item ${isActive ? 'active-session' : ''} ${currentTargetId === user.id ? 'selected' : ''} ${isExpired ? 'expired' : ''} ${isPinned ? 'pinned' : ''}`;
                
                const offlineText = isExpired ? ' (offline)' : '';
                const statusText = isActive ? ' üü¢' : (session && session.history.length > 0 ? ' ‚ö™' : '');
                d.innerHTML = `<canvas id="icon-${user.id}"></canvas> <span>${user.name}${offlineText}${statusText}</span>`;
                d.onclick = () => selectUser(user.id);
                container.appendChild(d);
                drawIcon(`icon-${user.id}`, user.pub.n);
            });
        };
        
        const pinnedContacts = savedContacts.filter(c => c.isPinned).sort((a, b) => a.name.localeCompare(b.name));
        const regularContacts = savedContacts.filter(c => !c.isPinned).sort((a, b) => a.name.localeCompare(b.name));
        
        if (pinnedContacts.length) renderSect("üìå Trusted Contacts", pinnedContacts);
        if (regularContacts.length) renderSect("Contacts", regularContacts);
        
        const activeDiscovery = groupAddressBook.filter(gu => 
            !savedContacts.find(sc => sc.id === gu.id) && 
            (!gu.expires || gu.expires > Date.now())
        );
        renderSect("Discovery", activeDiscovery);
    }

    function refreshChatBox() {
        const box = document.getElementById('chat-box'); box.innerHTML = "";
        const session = sessions.get(currentTargetId);
        if (session) {
            document.getElementById('chat-header').classList.remove('hidden');
            document.getElementById('recipient-name').innerText = session.remoteName;
            if (session.remoteJWK_N) drawIcon('recipient-thumb', session.remoteJWK_N);
            
            // Add session controls
            addSessionControls();
            
            // Update trust toggle button
            const contact = savedContacts.find(c => c.id === currentTargetId);
            const trustBtn = document.getElementById('trust-toggle');
            if (contact?.isPinned) {
                trustBtn.textContent = 'Trusted ‚úì';
                trustBtn.className = 'trust-toggle trusted';
            } else {
                trustBtn.textContent = 'Add to Trusted';
                trustBtn.className = 'trust-toggle';
            }
            
            session.history.forEach(m => renderMsg(m.sender, m.text, m.type, m.timestamp));
            document.getElementById('msg-input').disabled = !session.keyExchangeComplete;
            document.getElementById('send-btn').disabled = !session.keyExchangeComplete;
            document.getElementById('msg-input').placeholder = session.keyExchangeComplete ? "Message..." : (session.conn ? "Establishing secure session..." : "Click to reconnect...");
        } else {
            document.getElementById('chat-header').classList.add('hidden');
            box.innerHTML = '<div style="text-align:center; color:#444; margin-top:20%;">Select a recipient.</div>';
        }
    }

    function updateGroupsUI(list) {
        const c = document.getElementById('active-groups-list'); c.innerHTML = "";
        if(!list.length) { c.innerHTML = '<span style="color:#444; font-size: 0.7em;">None</span>'; return; }
        list.forEach(name => {
            const s = document.createElement('span'); s.className = 'group-tag'; s.innerText = name;
            s.onclick = () => { document.getElementById('group-name-input').value = name; };
            c.appendChild(s);
        });
    }

    function renderMsg(u, t, type, timestamp) {
        const d = document.createElement('div'); 
        d.className = `msg ${type}`;
        const time = timestamp ? new Date(timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
        d.innerHTML = `<small><b>${u}</b> ${time}</small><br>${escapeHtml(t)} <span class="verified-badge">‚úì Verified Identity</span>`;
        const b = document.getElementById('chat-box'); 
        b.appendChild(d); 
        b.scrollTop = b.scrollHeight;
    }
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    function addHistory(pid, s, t, type, timestamp = Date.now()) {
        if (!sessions.has(pid)) sessions.set(pid, { history: [], remoteName: pid });
        sessions.get(pid).history.push({ sender: s, text: t, type, timestamp });
        if (pid === currentTargetId) renderMsg(s, t, type, timestamp);
    }
    async function sendRegistration() {
        if (!lobbyConn?.open) return;
        const pub = await window.crypto.subtle.exportKey("jwk", myKeys.publicKey);
        lobbyConn.send({ type: 'REGISTER', data: { name: myName, id: peer.id, pub, expires: Date.now() + 90000 } });
    }
    function startTimer() {
        let tl = 300; const d = document.getElementById('timer-display');
        discoveryInterval = setInterval(() => {
            tl--; d.innerText = `Lobby Active: ${Math.floor(tl/60)}:${(tl%60).toString().padStart(2, '0')}`;
            if (tl <= 0) toggleDiscoverable();
        }, 1000);
    }
    function showKeyInfo(u, n) { 
        document.getElementById('overlay-username').innerText = u; 
        document.getElementById('overlay-key-text').innerText = n; 
        document.getElementById('key-overlay').classList.remove('hidden'); 
    }
    function closeKeyInfo() { document.getElementById('key-overlay').classList.add('hidden'); }
    async function toggleCurrentUserTrust() {
        if (!currentTargetId) return;
        const contact = savedContacts.find(c => c.id === currentTargetId);
        if (!contact) return;
        
        contact.isPinned = !contact.isPinned;
        await saveContact(contact.id, contact.name, contact.pub, contact.isPinned);
        savedContacts = await loadContacts();
        refreshAddressBookUI();
        refreshChatBox();
        
        const action = contact.isPinned ? 'added to trusted contacts' : 'removed from trusted contacts';
        showNotification(`${contact.name} ${action}`, 'success');
    }
    
    async function togglePin(userId) {
        const contact = savedContacts.find(c => c.id === userId);
        if (!contact) return;
        
        contact.isPinned = !contact.isPinned;
        await saveContact(contact.id, contact.name, contact.pub, contact.isPinned);
        savedContacts = await loadContacts();
        refreshAddressBookUI();
        
        const action = contact.isPinned ? 'pinned as trusted' : 'unpinned';
        showNotification(`${contact.name} ${action}`, 'success');
    }
    
    function cleanupInactiveUsers() {
        const now = Date.now();
        let cleaned = false;
        
        // Remove expired users from discovery list
        groupAddressBook = groupAddressBook.filter(user => {
            if (user.expires && user.expires < now) {
                cleaned = true;
                return false;
            }
            return true;
        });
        
        if (cleaned) {
            refreshAddressBookUI();
        }
    }
    
    function showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed; top: 20px; right: 20px; z-index: 3000;
            padding: 12px 20px; border-radius: 8px; color: white; font-size: 0.9em;
            background: ${type === 'error' ? 'var(--danger)' : type === 'success' ? 'var(--accent)' : 'var(--primary)'};
            box-shadow: 0 4px 12px rgba(0,0,0,0.3); animation: slideIn 0.3s ease;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 4000);
    }
    
    function copyOverlayKey() { 
        navigator.clipboard.writeText(document.getElementById('overlay-key-text').innerText)
            .then(() => showNotification('Key copied to clipboard', 'success'))
            .catch(() => showNotification('Failed to copy key', 'error'));
    }
    function inspectRemoteKey() { const s = sessions.get(currentTargetId); if (s?.remoteJWK_N) showKeyInfo(s.remoteName, s.remoteJWK_N); }
    function toggleProfile() { const m = document.getElementById('my-profile-modal'); m.style.display = m.style.display === 'block' ? 'none' : 'block'; }
    function toggleMobileSidebar() { 
        const sidebar = document.getElementById('sidebar');
        sidebar.classList.toggle('mobile-open');
    }
    function directConnect() { const id = document.getElementById('direct-id-input').value.trim(); if (id && id !== peer.id) selectUser(id); }
    async function exportKeys() {
        const b = new Blob([JSON.stringify({ name: myName, pub: await window.crypto.subtle.exportKey("jwk", myKeys.publicKey), priv: await window.crypto.subtle.exportKey("jwk", myKeys.privateKey) })], { type: "application/json" });
        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `id_${myName}.json`; a.click();
    }
</script>
</body>
</html>